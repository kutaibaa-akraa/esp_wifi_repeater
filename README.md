# esp_wifi_repeater
موجه واي فاي يعمل بكامل وظائفه (بشكل صحيح: موجه واي فاي NAT)

هذا تنفيذ لموجه واي فاي NAT على ESP8266 و ESP8285. يتضمن أيضًا دعمًا لجدار حماية تصفية الحزم مع قوائم التحكم بالوصول (ACLs)، وتخطيط المنافذ، وتشكيل حركة المرور، وخطافات للرصد عن بُعد (أو تص sniffing الحزم)، وواجهة إدارة MQTT، وتفاعل بسيط مع GPIO، وإدارة الطاقة. للإعداد مع عدة موجهات في شبكة mesh لتغطية منطقة أكبر، تم تضمين وضع جديد يسمى "Automesh". 

*إذا كنت تبحث عن طريقة لدمج ميزة NAT في مشروع Arduino الخاص بك* - راجع https://github.com/martin-ger/lwip_nat_arduino.

ميزة NAT *الأساسية المشابهة لـ ESP32* يمكن العثور عليها في: https://github.com/martin-ger/esp32_nat_router.

تشمل سيناريوهات الاستخدام النموذجية:
- ممدد نطاق بسيط لشبكة واي فاي موجودة
- شبكات خارجية تعمل بالبطارية (mesh)
- إعداد شبكة واي فاي إضافية مع SSID/كلمة مرور مختلفة للضيوف
- إعداد شبكة آمنة ومقيدة لأجهزة IoT
- ترجمة شبكات WPA2 Enterprise إلى WPA-PSK
- مسبار مراقبة لتحليل حركة مرور واي فاي
- تجارب شبكية مع مسارات، ACLs، وتشكيل حركة المرور
- أجهزة IoT متشابكة مع قدرات I/O أساسية وتحكم MQTT

بشكل افتراضي، يعمل ESP كـ STA وكمحول واي فاي ناعم (soft-AP) ويقوم بتوجيه أي حركة مرور IP عبره. نظرًا لأنه يستخدم NAT، لا يلزم وجود إدخالات توجيه لا على جانب الشبكة ولا على المحطات المتصلة. يتم تكوين المحطات عبر DHCP بشكل افتراضي في الشبكة 192.168.4.0/24 وتتلقى عنوان مستجيب DNS من شبكة واي فاي الموجودة.

تظهر القياسات أنه يمكن تحقيق حوالي 5 ميجابت في الثانية في كلا الاتجاهين، مما يجعل حتى البث ممكنًا.

يتم شرح بعض التفاصيل في هذا الفيديو: https://www.youtube.com/watch?v=OM2FqnMFCLw

# الإقلاع الأول
يبدأ esp_wifi_repeater بالإعدادات الافتراضية التالية:

- ap_ssid: MyAP, ap_password: none, ap_on: 1, ap_open: 1
- network: 192.168.4.0/24

بعد الإقلاع الأول (أو إعادة الضبط إلى الإعدادات الافتراضية)، سيعرض شبكة واي فاي مع AP مفتوح و SSID "MyAP". لن يحاول الاتصال تلقائيًا بشبكة AP uplink (لأنه لا يعرف SSID أو كلمة مرور صالحة).

اتصل بهذه الشبكة وقم بإجراء التكوين الأساسي إما عبر واجهة ويب بسيطة أو التكوين الكامل مع جميع الخيارات عبر الواجهة السطرية.

# واجهة تكوين الويب الأساسية
تسمح واجهة الويب بتكوين جميع المعلمات المطلوبة لوظيفة التوجيه الأساسية. شكرًا لـ rubfi على العمل الرئيسي في ذلك: https://github.com/rubfi/esp_wifi_repeater/. توجه إلى "http://192.168.4.1". يجب أن تظهر هذه الصفحة:

<img src="https://raw.githubusercontent.com/martin-ger/esp_wifi_repeater/master/WebConfig.jpg">

أولاً، أدخل القيم المناسبة لشبكة واي فاي uplink، "إعدادات STA". استخدم كلمة مرور "none" للشبكات المفتوحة. حدد مربع "Automesh" إذا وفقط إذا كنت تريد استخدام وضع Automesh. انقر على "اتصال". سيعيد ESP التشغيل وسيتصل بموجه واي فاي الخاص بك. يجب أن يبدأ مؤشر الحالة بالوميض بعد بضع ثوانٍ.

إذا كنت قد حددت Automesh، فقد انتهيت من التكوين. تكوين "إعدادات Soft AP" ليس مطلوبًا حيث أن هذه الإعدادات في وضع Automesh متطابقة مع "إعدادات STA". سيتم عرض نفس SSID من قبل جميع أجهزة ESP المكررة المتصلة.

إذا كنت لا تستخدم Automesh، يمكنك الآن إعادة تحميل الصفحة وتغيير "إعدادات Soft AP". انقر على "تعيين" وسيعيد ESP التشغيل مرة أخرى. الآن أصبح جاهزًا لتوجيه حركة المرور عبر Soft AP الجديد. كن على علم بأن هذه التغييرات تؤثر أيضًا على واجهة التكوين، أي لإجراء المزيد من التكوين، قم بالاتصال بـ ESP عبر إحدى شبكات واي فاي الجديدة التي تم تكوينها. للوصول عبر Soft AP، تذكر عنوان شبكة Soft APs إذا قمت بتغييره (دائمًا ما يكون عنوان ESP هو x.x.x.1 في هذه الشبكة).

إذا أردت، يمكنك تحديد مربع "قفل" والنقر على "قفل". الآن لا يمكن تغيير التكوين إلا بعد فتحه بكلمة مرور شبكة واي فاي uplink (حدد واحدة حتى إذا كانت الشبكة مفتوحة).

إذا كنت تريد إدخال أحرف غير ASCII أو خاصة في واجهة الويب، يجب عليك استخدام ترميز HTTP السداسي مثل "My%20AccessPoint". سيؤدي هذا إلى إنشاء سلسلة "My AccessPoint". باستخدام هذا الترميز السداسي، يمكنك إدخال أي قيمة بايت تريدها، باستثناء 0 (لأسباب داخلية في لغة C).

إذا قمت بخطأ وفقدت كل الاتصال بـ ESP، يمكنك仍然 استخدام الواجهة السطرية التسلسلية لاستعادتها ("إعادة ضبط المصنع"، انظر أدناه).

# واجهة سطر الأوامر
يجب إجراء التكوين المتقدم عبر سطر الأوامر على واجهة الكونسول. تتوفر هذه الواجهة إما عبر المنفذ التسلسلي بسرعة 115200 باود أو عبر منفذ TCP 7777 (على سبيل المثال، "telnet 192.168.4.1 7777" من محطة متصلة).

استخدم الأوامر التالية للإعداد الأولي:
- set ssid SSID_موجه_المنزل
- set password كلمة_مرور_موجه_المنزل
- set ap_ssid SSID_ESP
- set ap_password كلمة_مرور_ESP
- show (للتحقق من المعلمات)
- save
- reset

مرة أخرى، إذا كنت تريد إدخال أحرف غير ASCII أو خاصة، يمكنك استخدام ترميز HTTP السداسي (على سبيل المثال، "My%20AccessPoint") أو، فقط على CLI، كاختصار باستخدام علامات اقتباس على طراز C مع شرطة مائلة للخلف (على سبيل المثال، "My\ AccessPoint"). ستؤدي كلتا الطريقتين إلى إنشاء سلسلة "My AccessPoint".

يفهم سطر الأوامر الكثير من الأوامر الأخرى:

## الأوامر الأساسية
كافية لجعلها تعمل في几乎所有 البيئات.
- help: يطبع رسالة مساعدة قصيرة
- set [ssid|password] _value_: يغير إعدادات AP uplink (تكوين واي فاي لموجه المنزل)، استخدم كلمة مرور "none" للشبكات المفتوحة.
- set [ap_ssid|ap_password] _value_: يغير إعدادات soft-AP لـ ESP (للمحطات الخاصة بك)
- show [config|stats]: يطبع التكوين الحالي أو بعض معلومات الحالة والإحصائيات
- save [dhcp]: يحفظ معلمات التكوين الحالية، ACLs، وإدخالات التوجيه [+ تأجيرات DHCP الحالية] إلى الفلاش
- lock [_password_]: يحفظ ويقفل التكوين الحالي، لا يُسمح بالتغييرات. يمكن ترك كلمة المرور مفتوحة إذا تم تعيينها مسبقًا (الافتراضي هو كلمة مرور شبكة واي فاي uplink)
- unlock _password_: يفتح التكوين، يتطلب كلمة المرور من أمر القفل
- reset [factory]: يعيد تعيين ESP، 'factory' يعيد تعيين معلمات واي فاي إلى القيم الافتراضية (يعمل على جهاز مقفل فقط من واجهة الكونسول التسلسلية)
- quit: ينهي جلسة بعيدة

## الأوامر المتقدمة
معظم أوامر set تكون فعالة فقط بعد الحفظ وإعادة التعيين.

أي جزء من إدخال سطر الأوامر بعد علامة "#" وحتى نهاية السطر سيتم التعامل معه كتعليق وسيتم تجاهله.

### تكوين Automesh
- set automesh [0|1]: يحدد ما إذا كان وضع Automesh قيد التشغيل أو الإيقاف (الافتراضي)، راجع التفاصيل هنا https://github.com/martin-ger/esp_wifi_repeater#automesh-mode
- set am_threshold _dB_: يحدد الحد الأدنى لاتصال "سيء" (بالديسيبل السالب، الافتراضي 85، أي -85 ديسيبل)
- set am_scan_time _secs_: يحدد الفاصل الزمني بالثواني الذي تحاول فيه ESP في وضع Automesh العثور على AP uplink قبل الذهاب إلى وضع السكون (0 معطل، الافتراضي)
- set am_sleep_time _secs_: يحدد الفاصل الزمني بالثواني الذي تنام فيه ESP في وضع Automesh إذا لم يتم العثور على AP uplink (0 معطل، الافتراضي)

### تكوين واي فاي
- set ap_on [0|1]: يحدد ما إذا كان soft-AP معطلًا (ap_on=0) أو مفعلًا (ap_on=1، الافتراضي)
- set ap_open [0|1]: يحدد ما إذا كان soft-AP يستخدم أمان WPA2-PSK (ap_open=0، تلقائي، إذا تم تعيين ap_password) أو مفتوح (ap_open=1)
- set auto_connect [0|1]: يحدد ما إذا كان STA يجب أن يستمر في إعادة الاتصال بالAP. يتم إيقاف auto_connect (0) بعد التثبيت الأول أو بعد "reset factory". عند إدخال SSID جديد، سيتم تعيينه تلقائيًا على (1).
- set ssid_hidden [0|1]: يحدد ما إذا كان SSID لـ soft-AP مخفيًا (ssid_hidden=1) أو مرئيًا (ssid_hidden=0، الافتراضي)
- set phy_mode [1|2|3]: يحدد PHY_MODE للواي فاي (1=b، 2=g، 3=n(الافتراضي))
- set bssid _xx:xx:xx:xx:xx:xx_: يحدد BSSID محدد لـ AP uplink للاتصال به (الافتراضي 00:00:00:00:00:00 مما يعني أي)
- set [ap_mac|sta_mac] _xx:xx:xx:xx:xx:xx_: يحدد عنوان MAC لـ STA و SOFTAP إلى قيمة محددة من قبل المستخدم (لا يمكن أن يكون البت 0 من البايت الأول من عنوان MAC 1)
- set sta_mac random: يعين عنوان MAC عشوائي لـ STA بعد كل إعادة تشغيل
- set sta_hostname _name_: يحدد اسم STA (مرئي لـ AP uplink)
- set max_clients [1-8]: يحدد عدد المحطات التي يمكنها الاتصال بـ SoftAP (حد تنفيذ SoftAP لـ ESP هو 8، الافتراضي)
- scan: يقوم بمسح للبحث عن APs
- connect: يحاول الاتصال بـ AP باستخدام _ssid_ و _password_ المكونين حاليًا
- disconnect: يفصل الاتصال عن أي AP uplink

### تكوين WPA2 Enterprise
- set use_peap[0|1]: يحدد ما إذا كان STA يجب أن يتصل عبر WPA-PSK بسيط (use_peap=0، الافتراضي) أو باستخدام WPA2 Enterprise (PEAP)
- set peap_identity _value_: يحدد هوية PEAP 'الخارجية' (السلسلة التي يتم تقديمها أولاً لخادم RADIUS، ربما anonymous@yourorg.org)
- peap_username _value_: يحدد اسم مستخدم PEAP
- peap_password _value_: يحدد كلمة مرور PEAP

### تكوين TCP/IP
- set network _ip-addr_: يحدد عنوان IP للشبكة الداخلية، الشبكة دائمًا /24، الموجه دائمًا x.x.x.1
- set dns _dns-addr_: يحدد عنوان DNS ثابت يتم توزيعه على العملاء عبر DHCP
- set dns dhcp: يحدد استخدام عنوان DNS الديناميكي من DHCP، الافتراضي
- set ip _ip-addr_: يحدد عنوان IP ثابت لواجهة STA
- set ip dhcp: يحدد عنوان IP ديناميكي لواجهة STA، الافتراضي
- set netmask _netmask_: يحدد قناع شبكة ثابت لواجهة STA
- set gw _gw-addr_: يحدد عنوان بوابة ثابت لواجهة STA
- set max_nat _no_of_entries_: يحدد حجم جدول NAPT (الافتراضي 512)
- set max_portmap _no_of_entries_: يحدد حجم جدول تخطيط المنافذ (الافتراضي 32)
- set tcp_timeout _secs_: يحدد مهلة NAPT لاتصالات TCP (0=الافتراضي (1800 ثانية))
- set udp_timeout _secs_: يحدد مهلة NAPT لاتصالات UDP (0=الافتراضي (2 ثانية))
- set lease _min_: يحدد وقت التأجير بالدقائق لخادم DHCP للشبكة الداخلية (الافتراضي 120)
- show dhcp: يطبع الحالة الحالية لجدول تأجيرات DHCP

### التوجيه
- show route: يعرض جدول التوجيه الحالي
- route clear: يمسح جميع المسارات الثابتة
- route add _network_ _gw_: يضيف مسارًا ثابتًا إلى شبكة (يتم إعطاء الشبكة بتدوين CIDR ('x.x.x.x/n')) عبر بوابة gw
- route delete _network_: يزيل مسارًا ثابتًا إلى شبكة
- interface _inX_ [up|down]: يحدد حالة الواجهة up أو down (لا يتم توجيه IP/حركة المرور عبر الواجهات down، الافتراضي: up)
- set nat [0|1]: يحدد ما إذا كانت واجهة soft-AP تتمتع بـ NAT (nat=1، الافتراضي) أم لا (nat=0). بدون NAT، لا يعمل التوجيه الشفاف لحركة المرور من المحطات الداخلية! مفيد بشكل رئيسي مع التوجيه الثابت.
- portmap add [TCP|UDP] _external_port_ _internal_ip_ _internal_port_: يضيف توجيه منفذ
- portmap remove [TCP|UDP] _external_port_: يحذف توجيه منفذ
- nslookup _name_: يبدأ بحث DNS عن الاسم المعطى ويعرض النتيجة
- ping _host_: يتحقق من اتصال IP مع طلب/رد ICMP echo (host كعنوان IP أو اسم DNS)

### تكوين جدار الحماية/المراقبة
- acl [from_sta|to_sta|from_ap|to_ap] [TCP|UDP|IP] _src-ip_ [_src_port_] _desr-ip_ [_dest_port_] [allow|deny|allow_monitor|deny_monitor]: يضيف قاعدة جديدة إلى ACL
- acl [from_sta|to_sta|from_ap|to_ap] clear: يمسح ACL بالكامل
- show acl: يعرض ACLs المعرفة وبعض الإحصائيات
- set acl_debug [0|1]: يقوم بتبديل إخراج تصحيح أخطاء ACL تشغيل/إيقاف - سيتم تسجيل جميع الحزم المرفوضة إلى الطرفية
- set [upstream_kbps|downstream_kbps] _bitrate_: يحدد أقصى معدل بت صاعد/هابط (0 = بلا حد، الافتراضي)
- set daily_limit _limit_in_KB_: يحدد أقصى كمية كيلوبايت يمكن نقلها بواسطة المحطات يوميًا (0 = بلا حد، الافتراضي)
- set timezone _hours_offset_: يحدد المنطقة الزمنية المحلية (مطلوب لمعرفة متى ينتهي اليوم عند 00:00)
- monitor [on|off|acl] _port_: يبدأ ويوقف خادم المراقبة على منفذ معين

### تكوين واجهة المستخدم
- `set config_port _portno_`: يحدد رقم المنفذ لتسجيل الدخول إلى الواجهة السطرية (الافتراضي هو 7777، 0 يعطل تكوين الواجهة السطرية عن بُعد).
- `set web_port _portno_`: يحدد رقم المنفذ لخادم تكوين الويب (الافتراضي هو 80، 0 يعطل تكوين الويب).
- `set config_access _mode_`: يتحكم في الشبكات التي تسمح بالوصول إلى التكوين للواجهة السطرية والويب (0: لا يوجد وصول، 1: داخلي فقط، 2: خارجي فقط، 3: كليهما (الافتراضي)).

### تكوين GPIO
- `show gpio`: يعرض تكوين GPIO.
- `gpio [0-16] mode [_in_|_in_pullup_|_out_]`: يحدد وضع منفذ GPIO (محفوظ في الفلاش).
- `gpio [0-16] set [_high_|_low_]`: يكتب إلى منفذ إخراج.
- `gpio [0-16] set [_high_|_low_] for _seconds_`: يكتب إلى منفذ إخراج ويعود بعد مدة محددة.
- `gpio [0-16] get`: يقرأ من منفذ إدخال.
- `gpio [0-16] trigger [0-16] [_monostable_NO_|_monostable_NC_|_bistable_NO_|_bistable_NC_]`: يربط منفذ إدخال بمنفذ إخراج، إما كمفتاح أحادي الاستقرار عادي مفتوح (يتم تشغيله عند تغيير الحالة إلى منخفض)، أو أحادي الاستقرار عادي مغلق (يتم تشغيله عند تغيير الحالة إلى مرتفع)، أو ثنائي الاستقرار عادي مفتوح (يقلد حالة الإدخال)، أو ثنائي الاستقرار عادي مغلق (حالته عكس الإدخال).
- `gpio [0-16] trigger none`: يزيل الرابط.

### تكوين الشريحة
- `set speed [80|160]`: يحدد تردد ساعة المعالج (الافتراضي 160 ميجاهرتز).
- `sleep _seconds_`: يضع ESP في وضع السكون العميق لعدد محدد من الثواني (القيم الصالحة بين 1 و4294 ثانية (حوالي 71 دقيقة)).
- `set status_led _GPIOno_`: يحدد منفذ GPIO لمؤشر الحالة (الافتراضي 2، >16 يعطل).
- `set hw_reset _GPIOno_`: يحدد منفذ GPIO لإعادة الضبط إلى إعدادات المصنع (>16 يعطل، الافتراضي).
- `set ap_watchdog _secs_`: يحدد مهلة AP watchdog - إذا لم يتم استقبال أي حزم لمدة _secs_ من AP uplink، يتم إعادة تشغيل المكرر ("none" = بلا مهلة، الافتراضي).
- `set client_watchdog _secs_`: يحدد مهلة client watchdog - إذا لم يتم استقبال أي حزم لمدة _secs_ من أي عميل متصل، يتم إعادة تشغيل المكرر ("none" = بلا مهلة، الافتراضي).
- `set vmin _voltage_`: يحدد الحد الأدنى لجهد البطارية بالمللي فولت. إذا انخفض الجهد عن هذا الحد، يدخل ESP في وضع السكون العميق. إذا كان 0، لا يحدث شيء.
- `set vmin_sleep _secs_`: يحدد الفاصل الزمني بالثواني الذي ينام فيه ESP عند انخفاض الجهد.

# مؤشر الحالة
في التكوين الافتراضي، يتم تكوين GPIO2 لقيادة مؤشر حالة (متصل بـ GND) مع المؤشرات التالية:
- مضاء بشكل دائم: بدأ التشغيل، ولكن لم يتم الاتصال بنجاح بـ AP (لا يوجد عنوان IP خارجي صالح).
- وميض (مرة كل ثانية): يعمل، متصل بـ AP.
- وميض غير منتظم: يعمل، حركة مرور في الشبكة الداخلية.

مع الأمر `set status_led GPIOno` يمكن تغيير منفذ GPIO (أي قيمة > 16، على سبيل المثال `set status_led 255` يعطل مؤشر الحالة تمامًا). عند التكوين على GPIO1، يعمل مع مؤشر LED الأزرق المدمج في لوحات ESP-01. ومع ذلك، نظرًا لأن GPIO1 هو أيضًا منفذ UART-TX، فإن ذلك يعني أن الواجهة السطرية التسلسلية لن تعمل. التكوين يكون محدودًا عندئذٍ بالوصول إلى الشبكة.

# إعادة الضبط إلى إعدادات المصنع عبر العتاد
إذا قمت بسحب منفذ GPIO محدد إلى مستوى منخفض لأكثر من 3 ثوانٍ، سيقوم المكرر بإعادة الضبط إلى إعدادات المصنع وإعادة التشغيل بالإعدادات الافتراضية. مع الأمر `set hw_reset GPIOno` يمكن تغيير منفذ GPIO (أي قيمة > 16، على سبيل المثال `set hw_reset 255` يعطل ميزة إعادة الضبط إلى إعدادات المصنع عبر العتاد).

بالنسبة للعديد من الوحدات، بما في ذلك ESP-01s وNodeMCUs، من المحتمل أن تكون فكرة جيدة استخدام GPIO 0 لذلك، حيث يتم استخدامه على أي حال. ومع ذلك، فهو ليس المنفذ الافتراضي، حيث قد يتعارض مع سحبه إلى مستوى منخفض أثناء التثبيت. وبالتالي، إذا كنت تريد استخدام زر ضغط موجود على GPIO 0 لإعادة الضبط إلى إعدادات المصنع عبر العتاد، قم بتكوينه باستخدام `set hw_reset 0` و `save` بعد التثبيت. إعادة الضبط إلى إعدادات المصنع التي يتم تشغيلها عبر العتاد لن تعيد تعيين رقم GPIO المكون لإعادة الضبط إلى إعدادات المصنع (`reset factory` من الواجهة السطرية سيفعل ذلك).

# تخطيط المنافذ
لتمكين العملاء من الشبكة الخارجية من الاتصال بمنفذ خادم على الشبكة الداخلية، يجب تخطيط المنافذ. يتم تخطيط منفذ خارجي إلى منفذ داخلي لعنوان IP داخلي محدد. استخدم الأمر `portmap add` لذلك. يمكن سرد تخطيطات المنافذ باستخدام الأمر `show` ويتم حفظها مع التكوين الحالي.

ومع ذلك، للتأكد من أن الجهاز المتوقع يستمع لعنوان IP معين، يجب التأكد من أن هذا الجهاز لديه نفس عنوان IP بمجرد إعادة تشغيله أو إعادة تشغيل ESP. لتحقيق ذلك، يمكن تكوين عناوين IP ثابتة في الأجهزة أو يجب على ESP تذكر تأجيرات DHCP الخاصة به. يمكن تحقيق ذلك باستخدام الأمر `save dhcp`. يحفظ الحالة الحالية وجميع تأجيرات DHCP، بحيث يتم استعادتها بعد إعادة التشغيل. يمكن سرد تأجيرات DHCP باستخدام الأمر `show stats`.

# WPA2 Enterprise (PEAP)
تم تضمين دعم WPA2 Enterprise (PEAP) في المشروع. يسمح بإنشاء "محول" يقوم بترجمة شبكة WPA2 Enterprise مع مصادقة PEAP إلى شبكة WPA2-PSK. هذا يحل مشكلة شائعة خاصة في البيئات الجامعية: شبكة واي فاي المحلية هي شبكة WPA2 Enterprise مع مصادقة PEAP-MSCHAPv2. مثال بارز هو شبكة "eduroam" المتوفرة في العديد من الجامعات حول العالم. المشكلة هي أن العديد من أجهزة IoT لا يمكنها التعامل مع مصادقة WPA2 Enterprise. لذا فإن التطوير والعروض التوضيحية صعبة. ما هو مفيد للغاية هو "محول" يقوم بتسجيل الدخول إلى شبكة WPA2 Enterprise ويقدم شبكة WPA-PSK أبسط لعملائه.

لاستخدامه، قم بتعيين معلمات التكوين التالية: ssid، use_peap، peap_identity، peap_username، وpeap_password (لا تحتاج إلى معلمة كلمة المرور المعتادة). يجب إجراء هذا التكوين (وحفظه) عبر الواجهة السطرية ولا يتوفر في واجهة الويب.

لا يتحقق الكود حاليًا من شهادة خادم RADIUS. وهو عرضة لهجمات MITM، عندما يقوم شخص ما بإعداد AP وهمي وخادم RADIUS. بينما لا يتم إرسال كلمة المرور كنص عادي، فإن MSCHAPv2 المستخدم معروف بأنه معيب. أيضًا، كن على علم بأن ESP8266 يحتوي الآن على كلمة مرور شبكة المؤسسة الخاصة بك. يمكن لمسؤول الشبكة ربط كل حركة المرور التي يتم توجيهها عبره بحسابك. لا تسيء استخدامه وتقدمه للآخرين غير الموثوق بهم، على سبيل المثال، عن طريق تكوين شبكة مفتوحة. وحتى عندما يكون الجهاز مقفلاً، يمكن استخراج كلمة مرور شبكة المؤسسة الخاصة بك عبر المنفذ التسلسلي من فلاش ESP كنص عادي.

# وضع Automesh
في بعض الأحيان قد ترغب في استخدام عدة أجهزة esp_wifi_repeater في صف أو شبكة mesh لتغطية مسافة أو منطقة أكبر. بشكل عام، يمكن القيام بذلك دون أي مشاكل مع موجهات NAT، في الواقع سيكون لديك عدة طبقات من NAT. ومع ذلك، هذا يعني أن الاتصال محدود: يمكن لجميع العقد التحدث إلى الإنترنت، ولكن بشكل عام لا يوجد اتصال IP مباشر بين العقد. وبالطبع، تقل النطاق الترددي المتاح كلما زاد عدد القفزات التي تحتاجها. ولكن أبلغ المستخدمون أن حتى 5 أجهزة esp_wifi_repeater في صف تعمل بشكل جيد.

في مثل هذا الإعداد، يكون التكوين نشاطًا يستغرق وقتًا طويلاً وعرضة للأخطاء. لتبسيط ذلك، يحتوي esp_wifi_repeater الآن على وضع جديد: "Automesh". فقط قم بتكوين SSID وكلمة المرور وقم بتشغيل "automesh". (إما عبر الواجهة السطرية باستخدام `set automesh 1` أو عبر واجهة الويب عن طريق تحديد مربع الاختيار). سيقوم هذا بما يلي:

سيقوم كل esp_wifi_repeater تم تكوينه بهذه الطريقة بتقديم شبكة واي فاي على AP بنفس SSID/كلمة المرور التي يتصل بها. يمكن للعملاء استخدام نفس إعدادات واي فاي للشبكة الأصلية أو الشبكات المكررة. سيبدأ كل esp_wifi_repeater تم تكوينه باستخدام "automesh" بالبحث عن أفضل AP آخر للاتصال به. هذا هو الأقرب إلى شبكة واي فاي الأصلية ولديه أقوى إشارة (RSSI).

من السهل قياس قوة الإشارة باستخدام المسح، ولكن أي AP هو الأقرب إلى شبكة واي فاي الأصلية عندما ترى عدة APs بنفس SSID؟ لذلك يستخدم البروتوكول خدعة قذرة إلى حد ما: تقوم أجهزة esp_wifi_repeater في وضع "automesh" بالتلاعب بـ BSSID الخاص بها (في الواقع، وفقًا لمعيار IEEE 802.11، هذا هو "ESSID" لأنه AP، ولكن SDK يسميه "BSSID")، أي عنوان MAC لواجهة AP الخاصة بها، والذي يتم إرساله مع كل إطار beacon حوالي 10 مرات في الثانية. يستخدم التنسيق: 24:24:mm:rr:rr:rr. "24:24" هو مجرد معرف فريد للمكرر (هناك احتمال ضئيل أن يتصادم هذا مع عنوان MAC الحقيقي لـ AP، ولكن يمكننا إهمال ذلك، حيث يمكننا تغيير هذه البادئة إذا لزم الأمر). "mm" يعني "مستوى الشبكة"، وهي المسافة في القفزات إلى شبكة واي فاي الأصلية. الثلاثة الأخيرة "rr:rr:rr" هي مجرد أرقام عشوائية للتمييز بين أجهزة ESP المختلفة. يحتفظ AP الأصلي بـ BSSID الخاص به، أي الذي لا يحتوي على البادئة "24:24" يتم التعرف عليه كجذر، ويسمى مستوى الشبكة 0.

<img src="https://raw.githubusercontent.com/martin-ger/esp_wifi_repeater/master/AutoMesh.JPG">

الآن يمكن لكل esp_wifi_repeater معرفة أي esp_wifi_repeater آخر هو الأقرب إلى شبكة واي فاي الأصلية، والاتصال به، واختيار BSSID الخاص به وفقًا لذلك. أيضًا، يتم تعديل عنوان IP للشبكة الداخلية إلى مستوى الشبكة: 10.24.m.0. هذا ينشئ شجرة (شبكة mesh خاصة جدًا) مع AP واي فاي الأصلي كجذر وعقد مكررة على عدة مستويات شبكة (في الواقع، يعمل بشكل مشابه لبروتوكول Spanning Tree Protocol (STP) على طبقة الوصلة أو التوجيه على طبقة الشبكة باستخدام بروتوكول Distance Vector). بمجرد اكتشاف فقدان وصلة uplink، يتم إعادة بدء التكوين. يجب أن يتجنب هذا الحلقات، حيث أنه أثناء (إعادة) التكوين لا يتم إرسال إطارات beacon مع BSSID.

لتسهيل الأمر، يقوم esp_wifi_repeater بعد تكوين "automesh" بالتحقق أولاً مما إذا كان يمكنه الاتصال بـ AP uplink. إذا فشل ذلك، حتى إذا تم العثور على AP مع SSID صحيح، فإنه يفترض أن المستخدم أخطأ في كلمة المرور ويعيد الضبط إلى الإعدادات الافتراضية. بعد أن يتصل بنجاح مرة واحدة، سيفترض أن التكوين صحيح ويستمر في المحاولة بعد فقدان الاتصال أو إعادة التشغيل طالما استغرق الأمر (لتجنب هجوم DOS مع AP مكون بشكل خاطئ).

## ضبط Automesh
إذا كان هناك أكثر من ESP في النطاق، فقد يكون هناك مقايضة بين مسار "سيء" أقصر ومسار "جيد" أطول (جيد وسيء من حيث جودة الاتصال). تحدد المعلمة _am_threshold_ ما هو الاتصال السيئ: إذا كانت RSSI في المسح أقل من هذا الحد، فإن الاتصال سيئ ويتم تفضيل مسار مع قفزة إضافية. على سبيل المثال، إذا كانت _am_threshold_ هي 85 وهناك عقدتان automesh تم اكتشافهما في المسح: A مع المستوى 1 وRSSI -88 dB وB مع المستوى 2 وRSSI -60 dB، فإن الاتصال بـ A يعتبر سيئًا جدًا (-88 dB < -_am_threshold_) ويتم تفضيل B. ستصبح العقدة الجديدة عقدة من المستوى 3 مع uplink عبر B. يتم إعطاء _am_threshold_ كقيمة موجبة ولكنها تعني dB سالب. كلما كانت القيمة أصغر، كان ذلك أفضل.

إذا كنت ترغب في الحصول على مزيد من المعلومات حول طوبولوجيا شبكة automesh، يمكنك التفكير في توصيل جميع العقد بوسيط MQTT والسماح لها بنشر موضوع "Topology" (انظر أدناه). إذا قمت بالاشتراك الآن في "/WiFi/+/system/Topology"، فستحصل على جميع معلومات العقدة والرابط بما في ذلك RSSI (لأجهزة ESP المتصلة) التي تحتاجها لإعادة بناء الرسم البياني الكامل واكتشاف الروابط الضعيفة في الشبكة. يحتوي موضوع TopologyInfo على الهيكل JSON التالي، والذي يمكن استخدامه لإعادة بناء رسم بياني كامل لشبكة automesh:
```
{
"nodeinfo" {
	"id":"ESP_07e37e",
	"ap_mac":"24:24:01:72:c7:f9",
	"sta_mac":"60:01:bc:07:e3:7e",
	"uplink_bssid":"00:1a:54:93:23:0a",
	"ap_ip":"10.24.1.1",
	"sta_ip":"192.168.178.33",
	"rssi":"-66",
	"mesh_level":"1",
	"no_stas":"2"
},
"stas":[
	{"mac":"5c:cf:45:11:7f:13","ip":"10.24.1.2"},
	{"mac":"00:14:22:76:99:c5","ip":"10.24.1.3"}
]
}
```

باستخدام المعلمتين _am_scan_time_ و _am_sleep_time_، يمكن تنفيذ إدارة الطاقة في وضع automesh، إذا كنت قد قمت بتوصيل GPIO16 بـ RST. بعد التشغيل، يقوم esp_wifi_repeater بمسح APs uplink المتاحة لمدة _am_scan_time_ ثانية. إذا لم يتم العثور على أي منها، فإنه يدخل في وضع السكون العميق لمدة _am_sleep_time_ ثانية ويحاول مرة أخرى بعد إعادة التشغيل (الافتراضي هو 0 = معطل لكلا المعلمتين).

# المراقبة
من الواجهة السطرية، يمكن بدء خدمة مراقبة ("monitor on [portno]"). تعكس هذه الخدمة حركة مرور الشبكة الداخلية بتنسيق pcap إلى تدفق TCP. على سبيل المثال، باستخدام "netcat [external_ip_of_the_repeater] [portno] | sudo wireshark -k -S -i -" من جهاز كمبيوتر في الشبكة الخارجية، يمكنك الآن مراقبة حركة المرور في الشبكة الداخلية في الوقت الفعلي. استخدم هذا على سبيل المثال لمراقبة المواقع التي يتواصل معها عملاؤك الداخليون. كن على علم بأن هذا يضاعف على الأقل الحمل على ESP وشبكة واي فاي. تحت الحمل الثقيل، قد يؤدي ذلك إلى قطع بعض الحزم أو حتى إسقاطها في جلسة المراقبة. تحذير: ترك هذا المنفذ مفتوحًا يمثل مشكلة أمنية محتملة. يمكن لأي شخص من الشبكات المحلية الاتصال ومراقبة حركة المرور الخاصة بك.

# جدار الحماية
يحتوي موجه ESP على جدار حماية أساسي مدمج. يمكن تطبيق ACLs (قوائم التحكم بالوصول) على واجهة SoftAP. هذا حجر أساس في أمان IoT، عندما يتم استخدام الموجه لإدخال أجهزة IoT أخرى إلى الإنترنت. يمكن استخدامه لمنع أجهزة IoT التابعة لجهات خارجية من "الاتصال بالمنزل"، أو استخدامها كبرامج ضارة، وحماية شبكتك المنزلية مع أجهزة الكمبيوتر والأجهزة اللوحية والهواتف من أن تكون مرئية لأجهزة الأتمتة المنزلية.

تسمى قوائم ACLs الأربعة "from_sta"، "to_sta"، "from_ap"، و "to_ap" للحزم الواردة والصادرة على كلا الواجهتين ("sta" تعني الواجهات المتصلة بالعملاء، "ap" تعني الواجهة المتصلة بـ AP uplink). يتم تعريف ACLs بأسلوب "CISCO IOS".

المثال التالي مفيد لشبكة فرعية للضيوف. يسمح بالوصول إلى الإنترنت ولكن ليس إلى أي عناوين محلية أخرى (استخدم نطاق شبكتك المحلية لعنوان xx.xx.xx.xx). تسمح مجموعة القواعد هذه بالبث المحلي الصادر (لـ DHCP) و UDP 53 (DNS)، وسيتم حظر أي حزمة أخرى إلى الشبكة الفرعية لموجه uplink، ويمكن لجميع الحزم الأخرى المرور إلى الإنترنت:
```
acl from_sta clear
acl from_sta IP any 255.255.255.255 allow
acl from_sta UDP any any any 53 allow
acl from_sta IP any xx.xx.xx.xx/24 deny
acl from_sta IP any any allow
```

المثال التالي أكثر تقييدًا ومفيد عندما تخطط لشبكة فرعية IoT مع وصول مقيد للغاية في AP لـ ESP. سيسمح أيضًا بالبث المحلي الصادر (لـ DHCP)، و UDP 53 (DNS)، و TCP 1883 (MQTT) إلى وسيط محلي، ولكن سيتم حظر أي حزم أخرى، بما في ذلك الوصول التعسفي إلى الإنترنت (يمكنك تعديل العبارة الرابعة وفقًا لاحتياجاتك لتمكين مضيفين آخرين):
```
acl from_sta clear
acl from_sta IP any 255.255.255.255 allow
acl from_sta UDP any any any 53 allow
acl from_sta TCP any any 192.168.0.0/16 1883 allow
acl from_sta IP any any deny
```

يمكن أيضًا تعريف ACLs للاتجاه "to_sta"، ولكن هذا ليس مطلوبًا عادةً، حيث أن الاتجاه العكسي محمي جيدًا ضد حركة المرور غير المرغوب فيها بواسطة NAT.

تتكون ACLs من قواعد تصفية يتم معالجتها لكل حزمة. تتكون كل قاعدة من بروتوكول (IP، TCP، أو UDP)، عنوان/منفذ المصدر، عنوان/منفذ الوجهة، بالإضافة إلى إجراء "allow" أو "deny". في حالة IP العادي، لا يتم إعطاء منافذ، فقط عناوين. تتضمن قواعد IP حزم TCP و UDP. يمكن إعطاء العناوين كعناوين شبكة بتدوين "/"، على سبيل المثال 192.168.178.0/24. أيضًا، يمكن استخدام "any" كحرف بدل، حيث يتطابق مع أي عنوان أو رقم منفذ. يتم تعريف القاعدة باستخدام الأمر "acl":

- `acl [from_sta|to_sta|from_ap|to_ap] [TCP|UDP|IP] _src-ip_ [_src_port_] _desr-ip_ [_dest_port_] [allow|deny|allow_monitor|deny_monitor]`

يتم معالجة القواعد من الأعلى إلى الأسفل بترتيب ظهورها في القائمة. القاعدة الأولى التي تطابق الحزمة يتم تطبيقها وتحدد ما إذا كانت الحزمة مسموحًا بها (ويتم توجيهها) أو مرفوضة (ويتم إسقاطها). هذا يعني، الحالات الخاصة أولاً، القواعد العامة في النهاية. إذا كانت هناك قواعد في ACL، يتم رفض جميع الحزم التي لا تطابق أي قاعدة بشكل افتراضي. وبالتالي، القاعدة الأخيرة "from_sta IP any any deny" في المثال أعلاه ليست ضرورية حقًا، حيث أنها الافتراضية على أي حال. إذا كانت ACL فارغة، يتم السماح بجميع الحزم.

تعريف قواعد ACL يعمل أيضًا من الأعلى إلى الأسفل: يتم دائمًا إضافة قاعدة جديدة في نهاية القائمة. لتغيير ACL، يجب أولاً مسحها بالكامل (`acl from_sta clear`) ثم إعادة بنائها. يتم حفظ ACLs مع التكوين. `show acl` سيطبع ACLs بالإضافة إلى إحصائيات حول عدد الزيارات لكل قاعدة والعدد الإجمالي للحزم المسموح بها والمرفوضة.

مع الأمر `set acl_debug 1`، يتم طباعة ملخص لجميع الحزم المرفوضة إلى الواجهة السطرية. أيضًا، يمكن نشر هذا الملخص في موضوع MQTT. يمكن استخدام هذا لتكوين جدار الحماية لتحديد القواعد المطلوبة لجعل الأجهزة المتصلة تعمل. كما يعطي تلميحًا إذا حدثت حركة مرور غير متوقعة (وتم رفضها).

لتحليل أعمق، يمكن استخدام خدمة المراقبة (حتى الحزم المرفوضة يتم الإبلاغ عنها إلى المراقب قبل إسقاطها). عند بدء المراقب باستخدام الأمر `monitor acl _port_`، يمكن استخدام ACLs كمرشحات عبر الإنترنت. جميع القواعد التي يتم تعريفها كـ "allow_monitor" بدلاً من "allow" و "deny_monitor" بدلاً من "deny" يتم معالجتها كالمعتاد، مما يؤدي إلى السماح بتوجيه الحزمة، ولكنها أيضًا ترسل الحزمة إلى المراقب. وبالتالي، فإن قائمة القواعد التي تسمح بشكل أساسي بـ "allow" أو "allow_monitor" لجميع الحزم لا تزال منطقية، حيث يمكن استخدامها لتحديد الحزم التي يجب تسجيلها بالفعل أثناء وقت الالتقاط. على سبيل المثال، القوائم:
```
acl from_sta clear
acl from_sta IP 192.168.0.0/16 any allow_monitor
acl from_sta IP any any allow

acl to_sta clear
acl to_sta IP any 192.168.0.0/16 allow_monitor
cl to_sta IP any any allow
```

ستسمح لجميع الحزم وتختار أيضًا جميع الحزم للمراقبة التي تذهب من محطة إلى الشبكة الفرعية 192.168.0.0/16 (المحلية) ومن 192.168.0.0/16 إلى محطة. بالطبع، يمكن تطبيق مثل هذا المرشح أيضًا بعد الالتقاط على تتبع مراقبة كامل، ولكن إذا كنت تعرف بالفعل ما تبحث عنه، فإن هذه المرشحات عبر الإنترنت ستساعد في تقليل حمل المراقبة بشكل كبير. يمكن أيضًا استخدامها لتصحيح أخطاء جميع قواعد جدار الح firewall المرفوضة ببساطة باستخدام "deny_monitor" بدلاً من "deny".

# المسارات الثابتة
بشكل افتراضي، يتم تطبيق NAT على واجهة AP، بحيث يمكن لأي عقدة متصلة بـ AP الوصول إلى العالم الخارجي بشكل شفاف عبر واجهة STA لـ ESP. لذلك، لا يلزم اتخاذ أي إجراء إضافي، إذا لم تكن من محبي الشبكات الحقيقيين.

بالنسبة لأولئك الذين يهتمون حقًا بتكوين الشبكة الإضافي: تم تحسين مكدس lwip IPv4 لـ ESP لهذا المشروع لدعم المسارات الثابتة: `show route` يعرض جدول التوجيه مع جميع المسارات المعروفة، بما في ذلك الروابط إلى واجهات الشبكة المتصلة (واجهة AP وواجهة STA). يعمل التوجيه بين هاتين الواجهتين دون تكوين إضافي. يمكن تعيين مسارات إضافية إلى شبكات أخرى باستخدام الأمر `route add _network_ _gateway_`، المعروف من صناديق Linux أو الموجهات. يحفظ الأمر `save` الحالة الحالية لجدول التوجيه في تكوين الفلاش.

إليك مثال بسيط لما يمكن فعله مع المسارات الثابتة. بالنظر إلى إعداد الشبكة التالي مع ESPs متصلين بواجهات STA عبر موجه منزلي مركزي:
```
| 10.0.1.1 AP-ESP1-STA 192.168.1.10 | <-> |Home Router| <-> | 192.168.1.20 STA-ESP2-AP 10.0.2.1|
```
كل ESP لديه شبكة ثانية خلف AP الخاص به بعناوين شبكة مختلفة: 10.0.1.0/24 و 10.0.2.0/24. يمكن لـ ESP1 الاتصال بـ ESP2 إلى 192.168.1.20 ولكن ليس إلى 10.0.2.1، لأنه لا يعرف أنه يمكن الوصول إليه عبر 192.168.1.20. يتغير هذا إذا أضفت مسارين ثابتين. على ESP1:
```
route add 10.0.2.0/24 192.168.1.20
```
وعلى ESP2:
```
route add 10.0.1.0/24 192.168.1.10
```
الآن، `ping 10.0.2.1` على ESP1 سيكون ناجحًا. يتم إرساله إلى 192.168.1.20 ثم يتم الرد عليه بواسطة ESP2.

الآن في كل شبكة، يتصل عميل إضافي (بعناوين 10.0.1.2 و 10.0.2.2):
```
| STA1 10.0.1.2 | <-> | 10.0.1.1 ESP1 192.168.1.10 | <-> |Home Router| <-> | 192.168.1.20 ESP2 10.0.2.1| <-> | STA2 10.0.2.2 |
```
الآن حتى العميل STA1 مع العنوان المحلي 10.0.1.2 يمكنه الاتصال بـ STA2 مع 10.0.2.2 حيث يرسل طلبه أولاً إلى موجهه الافتراضي ESP1 وهذا يعرف أن جميع الحزم إلى عنوان 10.0.2.0/24 يجب توجيهها إلى 192.168.1.20. هناك، يعرف ESP2 كيفية إرسالها إلى STA2. ينطبق الشيء نفسه على الرد في الاتجاه المعاكس.

يسمح لك هذا بتكوين طوبولوجيا متعددة النجوم لـ ESPs، حيث يمكن لكل ESP وعملاء STA الوصول إلى بعضهم البعض مباشرة (دون الحاجة إلى تخطيط المنافذ). قد يكون تكوين المسارات المطلوبة مؤلمًا بعض الشيء - ولكنها تمرين جيد في الشبكات. الخطوة التالية ستكون نقل بروتوكول توجيه ديناميكي مثل RIP إلى ESP...

# حدود معدل البت
عن طريق تعيين upstream_kbps و downstream_kbps إلى قيمة غير 0 (0 هو الافتراضي)، يمكنك تحديد الحد الأقصى لمعدل البت لـ AP لـ ESP. هذه القيمة هي حد ينطبق على حركة مرور جميع العملاء المتصلين. يتم إسقاط الحزم التي تتجاوز معدل البت المحدد. يستخدم مشكل حركة المرور خوارزمية "Token Bucket" مع حجم دلو حاليًا أربعة أضعاف معدل البت في الثانية، مما يسمح باندفاعات عندما لا يكون هناك حركة مرور من قبل.

# دعم MQTT
منذ الإصدار 1.3، يحتوي الموجه على عميل MQTT مدمج (بفضل Tuan PM لمكتبته https://github.com/tuanpmt/esp_mqtt). يمكن أن يساعد ذلك في دمج الموجه/المكرر في IoT. يمكن لنظام أتمتة المنزل، على سبيل المثال، اتخاذ قرارات بناءً على معلومات حول المحطات المرتبطة حاليًا، ويمكنه تشغيل وإيقاف المكررات (على سبيل المثال، بناءً على جدول زمني)، أو يمكن استخدامه ببساطة لمراقبة الحمل. يمكن توصيل الموجه إما بوسيط MQTT محلي أو بوسيط متاح للجمهور في السحابة. ومع ذلك، فإنه لا يدعم حاليًا تشفير TLS.

بشكل افتراضي، يكون عميل MQTT معطلًا. يمكن تمكينه عن طريق تعيين معلمة التكوين "mqtt_host" إلى اسم مضيف مختلف عن "none". لتكوين MQTT، يمكنك تعيين المعلمات التالية:
- `set mqtt_host _IP_or_hostname_`: عنوان IP أو اسم المضيف لوسيط MQTT ("none" يعطل عميل MQTT).
- `set mqtt_port _port_`: منفذ وسيط MQTT المستخدم للاتصال (الافتراضي: 1883).
- `set mqtt_qos _QoS_`: قيمة QoS لـ MQTT للنشر والاشتراكات (0-2، الافتراضي: 0).
- `set mqtt_user _username_`: اسم المستخدم للمصادقة ("none" إذا لم تكن المصادقة مطلوبة في الوسيط).
- `set mqtt_password _password_`: كلمة المرور للمصادقة.
- `set mqtt_id _clientId_`: معرف العميل في الوسيط (الافتراضي: "ESPRouter_xxxxxx" مشتق من عنوان MAC).
- `set mqtt_prefix _prefix_path_`: البادئة لجميع المواضيع المنشورة (الافتراضي: "/WiFi/ESPRouter_xxxxxx/system"، مرة أخرى مشتق من عنوان MAC).
- `set mqtt_command_topic _command_topic_`: الموضوع المشترك لتلقي الأوامر، نفس الأمر من الواجهة السطرية. (الافتراضي: "/WiFi/ESPRouter_xxxxxx/command"، "none" يعطل الأوامر عبر MQTT).
- `set mqtt_interval _secs_`: يحدد الفاصل الزمني الذي ينشر فيه الموجه مواضيع الحالة (الافتراضي: 15 ثانية، 0 يعطل نشر الحالة).
- `set mqtt_mask _mask_in_hex_`: يحدد المواضيع التي يتم نشرها (الافتراضي: "ffff" يعني الكل).

يمكن عرض معلمات MQTT باستخدام الأمر `show mqtt`.

يمكن للموجه نشر مواضيع الحالة التالية بشكل دوري (كل mqtt_interval):
- `_prefix_path_/Uptime`: وقت التشغيل منذ آخر إعادة تعيين بالثواني (القناع: 0x0020).
- `_prefix_path_/Vdd`: جهد مصدر الطاقة بالمللي فولت (القناع: 0x0040).
- `_prefix_path_/Bpsin`: كيلوبايت/ثانية من المحطات إلى AP (القناع: 0x0800).
- `_prefix_path_/Bpsout`: كيلوبايت/ثانية من AP إلى المحطات (القناع: 0x0800).
- `_prefix_path_/Bpd`: كيلوبايت في اليوم من وإلى المحطات (القناع: 0x0400).
- `_prefix_path_/Ppsin`: حزم/ثانية من المحطات إلى AP (القناع: 0x0200).
- `_prefix_path_/Ppsout`: حزم/ثانية من AP إلى المحطات (القناع: 0x0200).
- `_prefix_path_/Bin`: إجمالي البايتات من المحطات إلى AP (القناع: 0x0100).
- `_prefix_path_/Bout`: إجمالي البايتات من AP إلى المحطات (القناع: 0x0100).
- `_prefix_path_/NoStations`: عدد المحطات المتصلة حاليًا بـ AP (القناع: 0x2000).
- `_prefix_path_/TopologyInfo`: هيكل JSON مع معلومات الطوبولوجيا الحالية للعقدة (القناع: 0x1000).

بالإضافة إلى ذلك، يمكن للمكرر النشر على أساس الأحداث:
- `_prefix_path_/join`: عنوان MAC لمحطة تنضم إلى AP (القناع: 0x0008).
- `_prefix_path_/leave`: عنوان MAC لمحطة تغادر AP (القناع: 0x0010).
- `_prefix_path_/IP`: عنوان IP للموجه عند استلامه عبر DHCP (القناع: 0x0002).
- `_prefix_path_/ScanResult`: موضوع منفصل لنتائج أمر "scan" (رسالة واحدة لكل AP تم العثور عليه) (القناع: 0x0004).
- `_prefix_path_/ACLDeny`: تم رفض حزمة بواسطة قاعدة ACL وتم إسقاطها (القناع: 0x0080).

كـ LWT وتقرير الحالة، ينشر المكرر:
- `_prefix_path_/status`: موضوع محتفظ به إما "online" (بمجرد اتصال المكرر) أو "offline" (بعد فقدان الاتصال كـ LWT).

يمكن تكوين الموجه باستخدام المواضيع التالية:
- `_command_topic_`: يشترك الموجه في هذا الموضوع ويفسر جميع الرسائل كأوامر سطرية.
- `_prefix_path_/response`: ينشر الموجه في هذا الموضوع إخراج سطر الأوامر (القناع: 0x0001).

إذا كنت تريد الآن أن ينشر الموجه على سبيل المثال فقط Vdd، عنوان IP الخاص به، وإخراج سطر الأوامر، قم بتعيين mqtt_mask إلى 0x0001 | 0x0002 | 0x0040 (= `set mqtt_mask 0043`).

# دعم ENC28J60 Ethernet
يتضمن esp_wifi_repeater الآن دعمًا لبطاقة شبكة ENC28J60 Ethernet المتصلة عبر SPI (بفضل Andrew Kroll https://github.com/xxxajk على عمله الرائع في تحقيق ذلك)، إذا قمت بتشغيل خيار التجميع HAVE_ENC28J60 في "user_config.h". ستوفر واجهة Ethernet حوالي 1 ميجابت في الثانية عندما يعمل ESP بتردد 160 ميجاهرتز. سيؤدي تشغيل واجهة AP واستخدام Ethernet كـ uplink إلى تحويل esp_wifi_repeater إلى AP رخيص لأجهزة واي فاي (على سبيل المثال، أجهزة ESP أخرى).

يجب أن يكون الاتصال عبر SPI كما يلي:
```
NodeMCU/Wemos  ESP8266      ENC28J60

        D6     GPIO12 <---> MISO
        D7     GPIO13 <---> MOSI
        D5     GPIO14 <---> SCLK
        D8     GPIO15 <---> CS
        D1     GPIO5  <---> INT
	D2     GPIO4  <---> RESET
               Q3/V33 <---> 3.3V
               GND    <---> GND
```
تعمل الأسلاك القصيرة والمحلومة بشكل أفضل. بالإضافة إلى ذلك، ستحتاج إلى ترانزستور لفصل GPIO15، وإلا فلن يتم تشغيل ESP بعد الآن، انظر: https://esp8266hints.wordpress.com/category/ethernet/. أيضًا، من المهم أن يكون لديك مصدر طاقة جيد: يحتاج ENC28j60 إلى حوالي 160mA عند التشغيل. بالنسبة لي، يفشل إذا حاولت استخدام 3.3V من لوحة ESP.

الآن يمكنك تكوين واجهة Ethernet الجديدة:
- `set eth_enable [0|1]`: يقوم بتمكين/تعطيل بطاقة شبكة ENC28J60 Ethernet على ناقل SPI (الافتراضي: 0 - معطل).
- `set eth_ip _ip-addr_`: يحدد عنوان IP ثابت لواجهة ETH.
- `set eth_netmask _netmask_`: يحدد قناع شبكة ثابت لواجهة ETH.
- `set eth_gw _gw-addr_`: يحدد عنوان بوابة ثابت لواجهة ETH.
- `set eth_dhcpd [0|1]`: يبدأ خادم DHCP لعناوين IP الديناميكية على واجهة ETH، (الافتراضي: 0 - معطل).

# إدارة الطاقة
يقوم المكرر بمراقبة جهد الإمداد الحالي (يظهر في الأمر `show stats`). يعمل هذا فقط إذا تم تعيين البايت 107 في esp_init_data_default.bin، المسمى vdd33_const، إلى 255(0xFF). أسهل طريقة لتحقيق ذلك هي كتابة esp_init_data_default_v08_vdd33.bin إلى الفلاش (انظر أدناه).

إذا تم تعيين _vmin_ (بالمللي فولت، الافتراضي 0) إلى قيمة > 0 وانخفض جهد الإمداد عن هذا الحد، فإنه يدخل في وضع السكون العميق لمدة _vmin_sleep_ ثانية. إذا كنت قد قمت بتوصيل GPIO16 بـ RST (وهو أمر صعب اللحام على ESP-01)، فإنه يعيد التشغيل بعد هذا الفاصل الزمني، ويحاول إعادة الاتصال، ويستمر في قياساته. إذا تم حفظ _vmin_ مع التكوين، فإنه ينام مرارًا وتكرارًا، حتى يرتفع جهد الإمداد فوق الحد. تكون هذه الإعدادات مفيدة بشكل خاص (فقط؟) إذا كنت قد قمت بتشغيل ESP ببطارية (ليثيوم) بدون حماية من التفريغ. عندئذٍ، تكون قيمة 2900mV-3000mV مفيدة على الأرجح، حيث تقلل من استهلاك الطاقة لـ ESP إلى الحد الأدنى ولديك وقت أطول لإعادة الشحن أو استبدال البطارية قبل التلف. هذا منطقي فقط إذا كنت قد قمت بتوصيل ESP مباشرة بالبطارية. إذا كان لديك منطق إضافي، فإنه سيستنزف البطارية.

يمكنك إرسال ESP إلى وضع السكون يدويًا مرة واحدة باستخدام الأمر `sleep`.

تحذير: إذا قمت بحفظ قيمة _vmin_ أعلى من أقصى جهد إمداد إلى الفلاش، فإن المكرر سيتم إيقافه على الفور في كل مرة بعد إعادة التشغيل. ثم يجب عليك مسح التكوين بالكامل عن طريق كتابة blank.bin (أو أي ملف آخر) إلى 0x0c000.

# البناء والتثبيت
إذا كان لديك Docker مثبتًا، فإن أسهل طريقة للحصول على بيئة البناء الكاملة هي توصيل ESP8266 بـ /dev/ttyUSB0 وتشغيل الصورة باستخدام:
```
git clone https://github.com/martin-ger/esp_wifi_repeater.git
docker run -it --rm --device=/dev/ttyUSB0 -v $(pwd)/esp_wifi_repeater:/home/esp/esp_wifi_repeater martinfger/iot_devel:1.0
cd esp_wifi_repeater
make
make flash
``` 

لإعداد بيئة البناء من الصفر وبناء هذا الثنائي، قم بتنزيل وتثبيت esp-open-sdk (أقترح هذا الإصدار مع قاعدة NONOS SDK 2.2: https://github.com/xxxajk/esp-open-sdk). تأكد من أنه يمكنك تجميع وتنزيل مثال "blinky" المضمن.

ثم قم بتنزيل شجرة المصدر هذه في دليل منفصل واضبط متغير BUILD_AREA في Makefile وأي خيارات مطلوبة في user/user_config.h. يمكن إجراء تغييرات على التكوين الافتراضي في user/config_flash.c. قم ببناء esp_wifi_repeater firmware باستخدام `make`. `make flash` يقوم بتثبيته على esp8266.

تتضمن شجرة المصدر نسخة ثنائية من liblwip_open بالإضافة إلى التضمينات الإضافية المطلوبة من نسختي من esp-open-lwip ونسخة ثنائية من أداة rboot. *لا يلزم أي إجراء تثبيت إضافي لذلك.* فقط إذا كنت لا تريد استخدام المكتبة المسبقة التجميع، قم بتنزيل المصادر من https://github.com/martin-ger/esp-open-lwip. استخدمها لاستبدال الدليل "esp-open-lwip" في شجرة esp-open-sdk. `make clean` في دليل esp_open_lwip ومرة أخرى `make` في الدليل العلوي esp_open_sdk. سيؤدي هذا إلى تجميع liblwip_open.a الذي يحتوي على ميزات NAT. استبدل liblwip_open_napt.a بهذا الثنائي. أيضًا، يمكنك بناء الثنائي "rboot.bin" من https://github.com/raburton/rboot واستبداله في الدليل الجذري للمشروع.

*تحديث*: إذا قرأت في مكان ما على الويب تعليمات التثبيت باستخدام "0x10000.bin" - بسبب OTA تم تغيير ذلك إلى "0x02000.bin" الآن.

إذا كنت تريد استخدام الثنائيات المسبقة التجميع الكاملة لـ firmware، يمكنك تثبيتها باستخدام "esptool.py --port /dev/ttyUSB0 write_flash -fs 4MB -ff 80m -fm dio 0x00000 firmware/0x00000.bin 0x02000 firmware/0x02000.bin" (استخدم -fs 1MB لـ ESP-01). بالنسبة لـ esp8285، يجب استخدام -fs 1MB و -fm dout.

على Windows، يمكنك تثبيته باستخدام "ESP8266 Download Tool" المتاح على https://espressif.com/en/support/download/other-tools. قم بتنزيل الملفين 0x00000.bin و 0x02000.bin من دليل firmware. بالنسبة لـ ESP12 عام، أو NodeMCU أو Wemos D1، استخدم الإعدادات التالية (لـ ESP-01 قم بتغيير FLASH SIZE إلى "8Mbit"):

<img src="https://raw.githubusercontent.com/martin-ger/esp_wifi_repeater/master/FlashRepeaterWindows.jpg">

إذا فشل وضع "QIO" على جهازك، جرب "DIO" بدلاً من ذلك. أيضًا، ألق نظرة على "Detected Info" للتحقق من حجم ووضع شريحة الفلاش. إذا لم يبدأ firmware الذي تم تنزيله بشكل صحيح، يرجى التحقق من المجاميع المضمنة لمعرفة ما إذا كانت الملفات الثنائية تالفة. إذا كنت في شك بشأن تلف ملفات firmware الثنائية، قم بتنزيل المستودع الكامل كـ zip واستخرج الثنائيات من ذلك zip - هذا يتجنب مشاكل تنزيل HTTP (على سبيل المثال، تحويلات CR-LF).

# دعم تحديث OTA (Over the air)

بناءً على استخدام مكتبة rboot: https://github.com/raburton/rboot وبفضل مساهمة christianchristensen.

تقوم عملية البناء بإنشاء نسختين من esp_wifi_repeater الثنائي في دليل firmware: 0x02000.bin و 0x82000.bin. بالنسبة للتثبيت الأولي، يكفي فقط تثبيت 0x00000.bin (برنامج تحميل rboot) و 0x02000.bin (نسخة واحدة من البرنامج). سيعمل esp_wifi_repeater.

إذا كان لديك على الأقل 1MB من الفلاش، يمكنك إجراء تحديث OTA (Over the air) بإصدار آخر. أي يمكنك تحميل ثنائي جديد بشكل تفاعلي من CLI والتبديل إليه. يتم تحميل الثنائي الآخر إلى موقع الذاكرة غير النشط حاليًا (إما 0x02000 (rom0) أو 0x82000 (rom1)) ويتم تشغيله عند النجاح. يمكنك أيضًا التبديل بشكل تفاعلي بين ثنائيين مثبتين. سيتم استخدام التكوين الحالي لكلا الثنائيين (طالما أن تنسيقه لم يتغير).

يمكنك التحكم في ميزات OTA باستخدام الأوامر التالية:
- `show ota`: يعرض الثنائي النشط حاليًا وعنوان URL للتحديث التالي.
- `set ota_host _hostname_`: يحدد اسم المضيف أو عنوان IP لخادم OTA (الافتراضي: "none").
- `set ota_port _portno_`: يحدد رقم المنفذ لخادم OTA (الافتراضي: 80).
- `ota update`: يحاول تنزيل ثنائي جديد (0x02000.bin أو 0x82000.bin) عبر HTTP من ota_host:ota_port ويبدأ تشغيله.
- `ota switch`: يتبدل إلى الثنائي الآخر (إذا كان مثبتًا).

لاختبار ميزة OTA، قم بتكوين ESP الخاص بك (كـ STA أو AP) للاتصال بالشبكة مع خادم التحديث. هناك، ابدأ خادم ويب بسيط في دليل firmware، على سبيل المثال:
```
cd firmware
python -m SimpleHTTPServer 8080
```
قم بتعيين المعلمة _hostname_ إلى اسم المضيف أو عنوان IP لجهاز الكمبيوتر الخاص بك، وقم بتعيين _portno_ إلى 8080، و `save`. ثم اكتب في CLI:
```
ota update
```
إذا تم التكوين بشكل صحيح، سيبدأ التحديث وسيعيد ESP التشغيل مع الثنائي الجديد.

# المشاكل المعروفة
- بسبب قيود تنفيذ SoftAP لـ ESP، هناك حد أقصى لـ 8 محطات متصلة في وقت واحد.
- يتطلب ESP8266 مصدر طاقة جيد حيث ينتج تيارًا ذرويًا يصل إلى 170 مللي أمبير أثناء الإرسال (يبلغ متوسط الاستهلاك النموذجي حوالي 70 مللي أمبير عندما تكون واي فاي قيد التشغيل). تحقق من مصدر الطاقة أولاً، إذا كان ESP الخاص بك يعمل بشكل غير مستقر ويعيد التشغيل من وقت لآخر. يمكن أن تساعد مكثف كبير بين Vdd و Gnd إذا واجهت مشاكل هنا.
- تم بناء جميع firmware المنشور بعد 17/أكتوبر/2017 مع الإصدار المصحح من SDK 2.1.0 من Espressif الذي يخفف من هجوم KRACK (https://www.krackattacks.com/).

# التراخيص
البرنامج مفتوح المصدر. تحتوي ملفات المصدر التابعة لجهات خارجية على رأس ترخيص خاص بها. بالنسبة لجميع الملفات الأخرى، ينطبق ترخيص MIT.